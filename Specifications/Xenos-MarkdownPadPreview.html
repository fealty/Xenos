<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Xenos.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
body{
    margin: 0 auto;
    font-family: Georgia, Palatino, serif;
    color: #444444;
    line-height: 1;
    max-width: 960px;
    padding: 5px;
    text-align: justify;
}
h1, h2, h3, h4 {
    color: #111111;
    font-weight: 400;
}
h1, h2, h3, h4, h5, p {
    margin-bottom: 16px;
    padding: 0;
}
h1 {
    font-size: 28px;
}
h2 {
    font-size: 22px;
    margin: 20px 0 6px;
}
h3 {
    font-size: 21px;
}
h4 {
    font-size: 18px;
}
h5 {
    font-size: 16px;
}
a {
    color: #0099ff;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
}
a:hover {
    text-decoration: none;
    color: #ff6600;
}
a:visited {
    color: purple;
}
ul, ol {
    padding: 0;
    margin: 0;
}
li {
    line-height: 24px;
    margin-left: 44px;
}
li ul, li ul {
    margin-left: 24px;
}
p, ul, ol {
    font-size: 14px;
    line-height: 20px;
    max-width: 540px;
}
pre {
    padding: 0px 24px;
    max-width: 800px;
    white-space: pre-wrap;
}
code {
    font-family: Consolas, Monaco, Andale Mono, monospace;
    line-height: 1.5;
    font-size: 13px;
}
aside {
    display: block;
    float: right;
    width: 390px;
}
blockquote {
    border-left:.5em solid #eee;
    padding: 0 2em;
    margin-left:0;
    max-width: 476px;
}
blockquote  cite {
    font-size:14px;
    line-height:20px;
    color:#bfbfbf;
}
blockquote cite:before {
    content: '\2014 \00A0';
}

blockquote p {  
    color: #666;
    max-width: 460px;
}
hr {
    width: 540px;
    text-align: left;
    margin: 0 auto 0 0;
    color: #999;
}

button,
input,
select,
textarea {
  font-size: 100%;
  margin: 0;
  vertical-align: baseline;
  *vertical-align: middle;
}
button, input {
  line-height: normal;
  *overflow: visible;
}
button::-moz-focus-inner, input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
button,
input[type="button"],
input[type="reset"],
input[type="submit"] {
  cursor: pointer;
  -webkit-appearance: button;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
}
/* override default chrome & firefox settings */
input:not([type="image"]), textarea {
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

input[type="search"] {
  -webkit-appearance: textfield;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
label,
input,
select,
textarea {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  font-weight: normal;
  line-height: normal;
  margin-bottom: 18px;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
  margin-bottom: 0;
}
input[type=text],
input[type=password],
textarea,
select {
  display: inline-block;
  width: 210px;
  padding: 4px;
  font-size: 13px;
  font-weight: normal;
  line-height: 18px;
  height: 18px;
  color: #808080;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}
select, input[type=file] {
  height: 27px;
  line-height: 27px;
}
textarea {
  height: auto;
}

/* grey out placeholders */
:-moz-placeholder {
  color: #bfbfbf;
}
::-webkit-input-placeholder {
  color: #bfbfbf;
}

input[type=text],
input[type=password],
select,
textarea {
  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;
  -moz-transition: border linear 0.2s, box-shadow linear 0.2s;
  transition: border linear 0.2s, box-shadow linear 0.2s;
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}
input[type=text]:focus, input[type=password]:focus, textarea:focus {
  outline: none;
  border-color: rgba(82, 168, 236, 0.8);
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
}

/* buttons */
button {
  display: inline-block;
  padding: 4px 14px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  line-height: 18px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  background-color: #0064cd;
  background-repeat: repeat-x;
  background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));
  background-image: -moz-linear-gradient(top, #049cdb, #0064cd);
  background-image: -ms-linear-gradient(top, #049cdb, #0064cd);
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));
  background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);
  background-image: -o-linear-gradient(top, #049cdb, #0064cd);
  background-image: linear-gradient(top, #049cdb, #0064cd);
  color: #fff;
  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
  border: 1px solid #004b9a;
  border-bottom-color: #003f81;
  -webkit-transition: 0.1s linear all;
  -moz-transition: 0.1s linear all;
  transition: 0.1s linear all;
  border-color: #0064cd #0064cd #003f81;
  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
}
button:hover {
  color: #fff;
  background-position: 0 -15px;
  text-decoration: none;
}
button:active {
  -webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}
button::-moz-focus-inner {
  padding: 0;
  border: 0;
}

/* CSS stylesheet is based on Kevin Burke's Markdown.css project (http://kevinburke.bitbucket.org/markdowncss) */
</style>
</head>
<body>
<blockquote>
  <p>Consider just adopting the .NET type system verbatim?</p>
</blockquote>

<h1>The Xenos Language Specification</h1>

<p>Xenos is <em>the stranger language</em> intended to enable programmers to write software via the literate programming paradigm and enable non-programmers to author documents using a friendly yet customizable markup language. Xenos programs are documents first, programs second. This core philosophy allows Xenos to meet the needs of both programmers and writers by inverting the conventional paradigms of each craft. The remainder of this document describes the Xenos language for implementation by compiler writers. Newbies to the language should read the introductory tutorials first.</p>

<h2>Program Structure</h2>

<p>The structure of Xenos programs consists of two parts: physical structure and logical structure. The physical structure requirements describe how the arrangement of source files on the native file system forms the physical structure. The logical structure requirements describe how the contents of physical elements, such as source files, form the logical structure. These two parts work together to maintain consistency through all editing, compiling, debugging, and reflecting done on Xenos programs.</p>

<h3>Physical Structure</h3>

<p>Xenos programs maintain consistency between the native file system representation and physical structure by deriving their physical structures from the presence or arrangement of source files and directories. This consistency ensures that programs will not accidentally create a physical or logical structure vastly different from how a complex Xenos program is viewed from within source code management solutions like Git.</p>

<h4>Source Files</h4>

<p>Source files are UTF-8 text files (without the byte order mark), containing Xenos source code, that have the <code>.xs</code> file extension. Implementations must accept source file names as the default argument to compiler invocation from the command line, and they may provide additional input paths. When processing the given source files, implementations must error when they encounter any of the following conditions:</p>

<ul>
<li>One or more source inputs contain byte order marks.</li>
<li>One or more source inputs use non-UTF-8 encoding schemes.</li>
<li>One or more source inputs lack the <code>.xs</code> file extension.</li>
<li>One or more related failures as determined by the implementation.</li>
</ul>

<h4>Modules</h4>

<p>Modules group related code and data as determined by programmers or writers. Modules are not source files; source files <em>describe</em> modules. Modules are primarily logical but derive their identifiers from the physical source files: Implementations must derive module identifiers by stripping the file system path, stripping the file extension, and replacing all lexically invalid identifier characters with underscores. For example, given the source file <code>My File.xdoc.xs</code>, implementations will derive <code>My_File_xdoc</code> as the module identifier.</p>

<h4>Namespaces</h4>

<p>Namespaces, like file system directories, group things. As such, implementations must treat directories as namespaces. The root directories of projects represent the global namespace for each project. Directories within the root directories form the physical namespace hierarchies for projects. Implementations must derive namespace identifiers from directory names by stripping the file system path relative to the current directory and replacing all lexically invalid identifier characters with underscores. For example, give the source file <code>./Frost Test/Shaping.xs</code>, implementations will determine that the <code>Shaping</code> module resides within the <code>Frost_Test</code> namespace.</p>

<h4>Libraries</h4>

<p>Libraries are .NET assemblies, which may be provided to implementations via a command line switch. Implementations should first check provided assemblies before looking in the global assembly cache. Implementations must expose all provided library members through the use of logical namespaces.</p>

<h3>Logical Structure</h3>

<p>The dependencies between modules, namespaces, and libraries form the logical structure of Xenos programs.</p>

<h4>Modules</h4>

<p>Modules are named scopes that list available code and data items. Every Xenos program has one master module that serves as the starting point to compilation, and every module thereafter must be processed only once, regardless of how many modules import each module. By recursively following import declarations, implementations build acyclic dependency trees for Xenos programs. Implementations must detect and emit errors when they encounter cycles between modules.</p>

<h4>Namespaces</h4>

<p>Namespaces are a logical abstraction for grouping available data and code into hierarchies. By this definition, the specification treats modules as namespaces in addition to physical directories and available library data. The dot is used to separate namespaces. For example, given the source file <code>./Frost Test/Shaping.xs</code>, implementations will determine that the Shaping module resides within the <code>Frost_Test.Shaping</code> namespace. Implementations must maintain lists of all namespaces available in referenced libraries and in the physical structure of the current project.</p>

<h2>Syntax</h2>

<p>The Xenos syntax follows a simple hierarchy: higher level structure followed by content. If text documents are sequences of paragraphs, Xenos source files are sequences of code and data blocks. In the case of literate programming, Xenos source files are paired sequences of one data block, consisting of markup content, followed immediately by one code block. To distinguish between these two types of blocks, implementations must implement the following section on interpretative modes.</p>

<h3>Interpretative Modes</h3>

<p>Implementations must implement the two interpretative modes: data and code, which form the basis for all possible content interpretation in Xenos program code.</p>

<h4>Data Mode</h4>

<p>All interpretation of program code begins in text mode, which is a built-in specialization of data mode designed to handle markup content.  </p>

<h5>Text Mode</h5>

<p>All source files begin in d</p>

<p>By default, all source files begin in text mode. They are given an implicit <strong>TextModeAttribute</strong> at the beginning of the file. This mode treats all items as implicit textual markup paragraphs, wrapping them with <code>\paragraph{&lt;item data&gt;}</code>. Any embedded code expressions, as denoted by unescaped <code>()</code>, will evaluate down to text instead of their object representations.</p>

<blockquote>
  <p>We have two broad goals in mind for Xenos: you can write a novel in it; you can write a video game in it. By choosing text mode as the default, we enable not only writing novels but encourage programmers to use literate programming to write their software. We allow embedded code expressions to allow for REPL and any kind of advanced text generation like a unit test report.</p>
</blockquote>

<h4>Code Mode</h4>

<p>When implementations encounter an attribute derived from <strong>CodeModeAttribute</strong>, implementations will switch to code mode. This mode treats all items exactly as they appear. Unlike text mode, code mode does not wrap items in any implicit context. This forbids writing paragraphs unless they are enclosed by an explicit <code>\paragraph{}</code>, but it allows code objects to evaluate to their object representations. When implementations encounter two or more consecutive blank lines, implementations must switch back to text mode. The end of files may also end the mode.</p>

<blockquote>
  <p>Text mode alone doesn't allow us to create programs because everything evaluates to text, not executable code. Code mode allows us to define functions on modules, types on modules, in addition to data like lists and hash tables. You know, the stuff that should actually get compiled.</p>
</blockquote>

<h4>Data Mode</h4>

<p>When implementations encounter an attribute derived from <strong>DataModeAttribute</strong>, implementations will switch to data mode. This mode treats all of the content as a verbatim string by default, but users can supply a <strong>DataModeProvider</strong> that provides an interface to the data. This interface can be accessed elsewhere in the source files. When implementations encounter three or more consecutive blank lines, implementations must switch back to text mode. The end of files may also end the mode.</p>

<blockquote>
  <p>We intend to allow the embedding of any textual content within source files. Users can embed XML data or code from another language if they wish. Our <strong>DataModeProvider</strong> enables code to access non-Xenos data at compile time through Xenos interfaces. We believe this is a very useful feature. This may be a generalization of text mode. If possible, we should look into implementing text mode through the use of data mode.</p>
</blockquote>

<h3>Everything is a Function Call</h3>

<p>All Xenos syntax transforms down into built-in and user-defined function calls. </p>

<h4>Basic Function Form</h4>

<p>The basic form of all function calls is defined as follows within opening and closing parentheses: zero or more <em>attributes</em>, each enclosed by a set of brackets; one or more characters of white space if attributes are given; the <em>function identifier</em> for the function being called; one or more characters of white space; zero or more <em>optional arguments</em>, each enclosed by a set of brackets; one or more characters of white space if optional arguments are given; and zero or more <em>required arguments</em>.</p>

<p><code>
([&lt;attribute&gt;]* &lt;function-identifier&gt; [&lt;optional-argument&gt;]* &lt;required-arguments&gt;*)
</code></p>

<blockquote>
  <p>We chose s-expressions because they are easy to parse. In order to support assigning attributes to arbitrary data structures---methods, parameters, member variables, etc.---we have chosen to allow attributes to be given in the s-expression and passed along to the function when evaluation occurs. This allows attributes to be used on s-expressions at compile time and pass through to arbitrary objects for application to compilation.</p>
</blockquote>

<h4>Attribute Form</h4>

<p>To make attributes distinct from normal function calls, implementations must implement the attribute form in addition to the basic form as follows: the <em>at-sign</em> followed immediately by the <em>attribute type</em>; one or more white space characters; zero or more <em>optional arguments</em>; one or more white space characters if optional arguments are given; zero or one parenthetical set enclosing zero or more <em>required arguments</em>.</p>

<p><code>
@&lt;attribute-type&gt; [&lt;optional-arguments&gt;]* (&lt;required-arguments&gt;*)?
</code></p>

<p>The attribute form transforms into the basic construction form as follows:</p>

<p><code>
(new &lt;attribute-type&gt; &lt;optional-arguments&gt; &lt;required-arguments&gt;)
</code></p>

<blockquote>
  <p>We wanted attributes to stand out in both code and text. They also needed a unique syntactic sugar to avoid having to new them manually.</p>
</blockquote>

<h4>Text Markup Form</h4>

<p>Xenos programs require large amounts of text. For this purpose, implementations must implement the text markup form as follows: a single backslash followed by the <em>markup type</em>; zero or more spaces; zero or more <em>optional arguments</em>, each enclosed by a set of brackets; zero or more spaces; a set of braces if <em>nested markup</em> is given.</p>

<p><code>
\&lt;markup-type&gt; [&lt;optional-arguments&gt;]* {&lt;nested-markup&gt;}?
</code></p>

<p>The text markup form itself transforms down into the following:</p>

<p><code>
(new &lt;markup-type&gt; &lt;optional-arguments&gt; &lt;required arguments&gt;)
</code></p>

<p>For example, consider the following line of nested markup:</p>

<p><code>
\paragraph{Hello, this is a paragraph of \emphasize{nested markup} text.}
</code></p>

<p>The markup form treats everything aside from other forms as text, so in basic form, the above becomes as follows:</p>

<p><code>
(new paragraph “Hello, this is a paragraph of ” 
  (new emphasize “nested markup”) “text.”)
</code></p>

<blockquote>
  <p>We needed a way to build trees of text markup. The text markup form easily enables this, solving the problem of including large amounts of semantic text.</p>
</blockquote>

<h4>Replacement Form</h4>

<p>To enable literate programming within modules, implementations must provide the s-expression replacement form, which is defined as follows: the dollar sign followed by a <em>function</em> that returns an s-expression; zero or more spaces; zero or more <em>optional arguments</em>, each enclosed in a set of brackets; zero or more spaces; zero or one set of parentheses having zero or more <em>required arguments</em> enclosed. </p>

<p><code>
$&lt;function&gt; [&lt;optional-arguments&gt;]* (&lt;required-arguments&gt;)?
</code></p>

<p>This form transforms down into the following immediately after the AST is built for its containing module item:</p>

<p><code>
(&lt;function&gt; [&lt;optional arguments&gt;]* &lt;required-arguments&gt;)
</code></p>

<blockquote>
  <p>We need a way to include chunks of code by name, so we devised the replacement form as a special function call always evaluated immediately after an module item's AST is fully built. This enables users to include chunks of AST from within the module and from dependent modules.</p>
</blockquote>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->